# 内核空间和用户空间 
对于32位的操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间，逻辑地址，即他们的实际物理地址是不一样的，即便是分配到了同一片地址上，只需要映射给不同的物理地址就好了，这样就做到了互不冲突）为4G（2的32次方|所以我们常见的32为操作系统最高内存只支持4G，而64位系统支持17179869184G大小的内存，对比发现存储的发展是远低于CPU的发展的）。也就是一个进程最大寻址空间为4G。操作系统的核心是内核（kernel），**它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权。**为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。针对Linux操作系统（32位）而言，最高的1G字节地址空间（从虚拟地址0xC0000000到0xFFFFFFFF）由内核空间使用，**（issue：那么现如今64位的linux内核享有多少寻址空间？）**称为内核空间，而较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）由各个进程使用，称为用户空间。

> 猜测：因为用户空间会被频繁的访问且有一定的不确定性，所以将内核空间放在高位地址。


# 为什么需要区分内核空间与用户空间
在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清理内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。<br/>
CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如Intel的CPU将权限分为四个等级：Ring0~Ring3<br/>
其实Linux系统只使用了Ring0和Ring3两个运行等级（Windows也一样）。当进程运行在Ring3级别时被称为运行在用户态，而运行在Ring0级别时被称为运行在内核态。<br/>

从计算机组成原理的最基础理论开始讲，我们都知道冯诺依曼体系的五个最重要的部分：运算器、控制器、存储器、输入设备、输出设别。CPU主要是运算器和控制器，以及一部分存储器（寄存器，转换内存与CPU速率不匹配的问题）
其中，运算器是无状态的；控制器配合一部分寄存器，但是寄存器数量很少，而且通常很容易被修改；输入设备、输出设备只有接受指令的时候才有动作。归根结底来说，整个计算机的运行状态几乎完全由存储器和少数几个寄存器控制。
也就是说，一段程序能够完全控制物理内存，那么它就能做到任意改变计算机的状态，**包括干掉整个操作系统然后自己变成操作系统，或者把自己变成操作系统的一部分**。

早期的DOS就是这样的操作系统，用户程序与操作系统程序并无区别之分，用户可以随便访问修改操作系统的数据，可以自己访问大部分的硬件设备，病毒也五花八门的安插在各个可能存在的位置。所以必须要限制应用程序行为，在应用程序和操作系统执行时由不同的状态，核心问题在于保存关键寄存器和重要的物理内存。

### 内核态和用户态
在内核态下，进程运行在内核地址空间中，此时CPU可以执行任何指令，运行的代码也不受任何的限制，可以自由的访问任何有效的地址，也可以直接进行端口的访问。<br/>
在用户态下，进程运行在用户地址空间中，被执行的代码需要受到CPU的诸多检查，它们只能访问映射其地址空间的页表项中规定在用户态下可访问页面的虚拟地址，且只能对任务状态段（TSS）中的I/O许可位图（I/O Permission Bitmap）中规定的可访问端口进行访问。<br/>

### 从CPU设计上谈内核态与用户态
