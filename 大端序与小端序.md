# 字节序

字节序，又称端序或尾序（Endianness），在计算机领域中，指电脑内存中或在数字通讯链路中，占用多少个字节的数据的字节排列顺序。<br/>

几乎在所有平台上，多字节对象都被存储为连续字节序列。例如：<br/>
一个字节最大可以存储 255，那么 256 就需要两个字节来存储了。用 16 进制来表示就是 0x0100（256）这时候，可以发现，高字节部分就是 01，低字节部分则是 00。<br/>

在计算机存储中，内存也被区分为低位地址到高位地址，这样就区分出了两种情况来存储数据的高字节和低字节部分：<br/>

- 大端序，将数据的**高位字节**存在内存的低位地址中。
- 小端序，将数据的**低位字节**存在内存的低位地址中。

```

           高——>低
    数据：0x12345678

    大端序              小端序

    0x01 —— 12         0x01 —— 78
    0x02 —— 34         0x02 —— 56
    0x03 —— 56         0x03 —— 34
    0x04 —— 78         0x04 —— 12

```

## 为何要有字节序

根据计算机电路来看会内存中会从低地址开始处理，效率比较高。但是由于数据不管先访问高字节数据还是低字节数据应该也没什么区别（先高字节，即大端序便于理解），同时也由于各个厂商的不同，Intel、AMD...不同的厂商也推出了各种不同的字节序，主机字节序也多了不确定性。出现网络通讯以后，为了解决这个不统一的问题，TCP/IP，RFC1700 规定使用“大端序”作为网络字节序。所以不管主机字节序是什么，都应该转换为网络字节序才能进行数据传输。

> 为了方便提供了转换函数供程序员使用：

    主机字节序转网络：htons（16位）、htonl（32位）
    网络字节序转主机：ntons（16位）、ntonl（32位）



```C
//判断大小端序
#include <stdio.h>

int main(){
    unsigned int x = 0x12345678;
    // 获取x的地址，取一个字节
    char* c = (char*)&x;

    // c指向x的第一块地址，通过判断第一块地址里的数据从而可以推出大小端序
    if(*c == 0x78){

        // 低地址存低字节数据
        printf("小端序");
    }else{

        // 低地址存高字节数据
        printf("大端序");
    }
}

```


## 身边的字节序
字符编码方式UTF-16，UTF-32同样面临字节序的问题，因为他们分别使用2个字节和4个字节编码Unicode字符，一旦某个值由多个字节表示，就必须要考虑到存储顺序的问题了。于是，采用了最简单粗暴的方式，给这个文件头部多写几个字符，用来表示大端序还是小端序。

```

    BOM|头部的字符           编码                      端序
    FF FE               UTF-16/UCS-2                Little endian
    FE FF               UTF-16/UCS-2                Big endian
    FF FE 00 00         UTF-32/UCS-4                Little endian
    00 00 FE FF         UTF-32/UCS-4                Big endian

```
上述的都是多字节编码，为什么没有提到常见的UTF-8呢，因为UTF-8是单字节编码的，也就是说从一开始就不会出现端序问题。但是微软为了统一UTF-X的操作，就硬给UTF-8加了BOM，内容为EF BB BF。
这样的话，在Windows下写Shell脚本，就会出现无法识别的问题:
shell会去找以#!/usr/bin/env bash的编码，而UTF-8却以EF BB BF开头。所以有BOM的话shell解释器就报错了。

